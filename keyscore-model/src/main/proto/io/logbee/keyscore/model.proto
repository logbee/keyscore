syntax = "proto3";

import "google/protobuf/timestamp.proto";
import "scalapb/scalapb.proto";

option (scalapb.options) = {
    package_name: "io.logbee.keyscore.model"
    flat_package: true
};

message Dataset {
    MetaData metadata = 1 [(scalapb.field).no_box = true];
    repeated Record records = 2;
}

message MetaData {
    option (scalapb.message).companion_extends = "io.logbee.keyscore.model.MetaDataConversion";
    repeated Label labels = 1;
}

message Label {
    option (scalapb.message).companion_extends = "io.logbee.keyscore.model.LabelConversion";
    string name = 1;
    Value value = 2;
}

message Record {
    option (scalapb.message).companion_extends = "io.logbee.keyscore.model.RecordCompanion";
    repeated Field fields = 2;
}

message Field {
    option (scalapb.message).companion_extends = "io.logbee.keyscore.model.FieldConversions";
    string name = 1;
    Value value = 2;
}

message Value {
    option (scalapb.message).companion_extends = "io.logbee.keyscore.model.ValueConversion";
    oneof sealed_value {
        TextValue text = 1;
        NumberValue number = 2;
        DecimalValue decimal = 3;
        TimestampValue timestamp = 4;
    }
}

message TextValue {
    option (scalapb.message).companion_extends = "io.logbee.keyscore.model.TextValueConversion";
    string value = 1;
}

message NumberValue {
    option (scalapb.message).companion_extends = "io.logbee.keyscore.model.NumberValueConversion";
    sint32 value = 1;
}

message DecimalValue {
    option (scalapb.message).companion_extends = "io.logbee.keyscore.model.DecimalValueConversion";
    double value = 1;
}

message TimestampValue {
    option (scalapb.message).companion_extends = "io.logbee.keyscore.model.TimestampValueConversion";
    // Represents seconds of UTC time since Unix epoch
    // 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
    // 9999-12-31T23:59:59Z inclusive.
    int64 seconds = 1;
    // Non-negative fractions of a second at nanosecond resolution. Negative
    // second values with fractions must still have non-negative nanos values
    // that count forward in time. Must be from 0 to 999,999,999
    // inclusive.
    int32 nanos = 2;
}
