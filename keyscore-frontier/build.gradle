import com.bmuschko.gradle.docker.tasks.container.DockerCreateContainer
import com.bmuschko.gradle.docker.tasks.container.DockerRemoveContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStartContainer
import com.bmuschko.gradle.docker.tasks.container.DockerStopContainer
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile

import io.logbee.gradle.scalapb.ScalaPBPlugin

apply plugin: ScalaPBPlugin

apply from: rootProject.file('dependencies.gradle')

evaluationDependsOn ':keyscore-commons'

project.ext {
    distributionDir = "$buildDir/distribution"
    dockerImageName = "$dockerImageHost/$dockerImageNamespace/${project.name}"
}

dependencies {

    compile project(':keyscore-commons')
    compile project(':keyscore-model')

    compile dependency.scala_lang
    compile dependency.akka_actor
    compile dependency.akka_persistence
    compile dependency.akka_stream
    compile dependency.akka_slf4j
    compile dependency.akka_http
    compile dependency.akka_http_json
    compile dependency.akka_http_cors
    compile dependency.akka_persistence
    compile dependency.akka_cluster
    compile dependency.keycloak

    runtime project(':keyscore-commons:keyscore-commons-logging')
    runtime dependency.logback

    testCompile project(':keyscore-test-fixtures')

    testCompile dependency.scala_test
    testCompile dependency.akka_testkit

    testCompile dependency.junit
}

apply plugin: 'nebula.ospackage'

jar {
    exclude('**/.keep')
    manifest.attributes([
        'Main-Class'                   : mainClass,
        'Implementation-Title'         : project.name,
        'Implementation-Version'       : version,
        'Implementation-Revision'      : revision,
        'Implementation-Revision-Date' : revisionDate,
        'Implementation-Build-Date'    : buildDate,
        'Implementation-Vendor'        : 'logbee.io',
        'Class-Path'                   : (configurations.runtime + configurations.compile).collect { "libs/" + it.getName() }.join(' ')
    ])
}

generateScalaPB {
    dependsOn project(':keyscore-commons').tasks['jar']
}

distributions {
    main {
        contents {
            from('src/launcher/keyscore-frontier')
            from(jar.outputs) {
                rename("${project.name}-${version}.jar", "${project.name}.jar")
            }
            from(configurations.runtime) {
                into 'libs'
            }
        }
    }
}

ext.compv = { p1 ->
    def result = version

    switch (p1) {
        case "deb":
            break
        case "rpm":
            // ugly
            result = result.replace("-alpha.", ".a").replace("-beta.", ".b")
            break
    }

    return result
}

/**
 * Creates buildDeb and buildRpm
 */
ospackage {
    packageName         = 'keyscore-frontier'
    packageDescription  = 'The holy Frontier of Keyscore'
    maintainer          = 'mlandth'
    vendor              = 'logbee'
    url                 = 'https://github.com/logbee/keyscore'

    os                  = 'LINUX' // only applied to RPM

    //scripts
    postInstall file('src/scripts/debian_post_install.sh')
    preUninstall file('src/scripts/debian_pre_removal.sh')

    //install location
    into '/usr/share/keyscore/keyscore-frontier'

    //source files
    from(project.tasks['installDist']) {
        into 'bin'
    }

    from('src/scripts') {
        into 'scripts'
    }

    from("$project.gradle.gradleUserHomeDir/jdk")
}

buildDeb {
    dependsOn {
        [':unpackJDK', project.tasks['installDist']]
    }
    version = compv("deb")
    release = project.findProperty('debRelease')
    arch    = 'amd64' //default = all
}

buildRpm {
    dependsOn {
        [':unpackJDK', project.tasks['installDist']]
    }
    version = compv("rpm")
    release = project.findProperty('rpmRelease')
    epoch   = 0 //default = 0
    arch    = 'X86_64' //(String) default = NOARCH
}

//TODO dependsOn buildDeb
task buildDockerfile(type: Dockerfile, dependsOn: 'buildDeb') {
    destFile = project.file("$buildDir/tmp/Dockerfile")
    from 'quay.io/logbee/docker-buster-slim:latest'
    def deb = "keyscore-frontier_${compv("deb")}-${project.findProperty('debRelease')}_amd64.deb"
    instruction { "COPY build/distributions/$deb /tmp/" }
    instruction { "RUN /usr/bin/dpkg -i /tmp/$deb && rm /tmp/$deb" }
    instruction { "CMD /usr/share/keyscore/keyscore-frontier/bin/keyscore-frontier" }
    instruction { 'EXPOSE 4711' }
}

task buildDockerImage(type: DockerBuildImage, dependsOn: [installDist, buildDockerfile]) {
    inputDir = projectDir
    dockerFile = buildDockerfile.destFile
    tag = "$dockerImageName:$version"
}

task createDockerContainer(type: DockerCreateContainer) {
    dependsOn buildDockerImage
    containerName = "keyscore-frontier"
    targetImageId { buildDockerImage.getImageId() }
    portBindings = ['2551:2551', '4711:4711']
    hostName = project.name
    env = [
            'KEYSCORE_CLUSTER_SEED_NODE_HOST=keyscore-frontier',
            'KEYSCORE_CLUSTER_SEED_NODE_HOST_2=keyscore-frontier-sleeping',
            'KEYSCORE_REMOTE_HOST=keyscore-frontier',
            'KEYSCORE_REMOTE_PORT=2551',
            'KEYSCORE_REMOTE_BIND_HOST=0.0.0.0',
            'KEYSCORE_OPERATING_MODE=true'
    ]
    network = project.findProperty('containerNetwork') ?: 'host'
}

task createSleepingContainer(type: DockerCreateContainer) {
    dependsOn buildDockerImage
    containerName = "keyscore-frontier-sleeping"
    targetImageId { buildDockerImage.getImageId() }
    portBindings = ['2552:2552']
    hostName = "keyscore-frontier-sleeping"
    network = project.findProperty('containerNetwork') ?: 'host'
    env = [
            'KEYSCORE_CLUSTER_SEED_NODE_HOST=keyscore-frontier',
            'KEYSCORE_CLUSTER_SEED_NODE_HOST_2=keyscore-frontier-sleeping',
            'KEYSCORE_REMOTE_HOST=keyscore-frontier-sleeping',
            'KEYSCORE_REMOTE_PORT=2552',
            'KEYSCORE_REMOTE_BIND_HOST=0.0.0.0',
            'KEYSCORE_REMOTE_BIND_PORT=2552',
            'KEYSCORE_OPERATING_MODE=false'
    ]
}

task startDockerContainer(type: DockerStartContainer) {

    dependsOn = ['createDockerContainer', ':setupDockerNetwork']
    targetContainerId { createDockerContainer.containerName }
}

task startSleepingContainer(type: DockerStartContainer) {

    dependsOn = ['createSleepingContainer', ':setupDockerNetwork']
    targetContainerId { createSleepingContainer.containerName }
}

task stopDockerContainer(type: DockerStopContainer) {
    targetContainerId { createDockerContainer.containerName }
    onError { exception ->
        if (exception.class.simpleName.matches('^(NotModified|NotFound)Exception$')) {
            println("Container " + createDockerContainer.containerName + " has already been stopped")
        }
        else throw exception
    }

}

task stopSleepingContainer(type: DockerStopContainer) {
    targetContainerId { createSleepingContainer.containerName }
    onError { exception ->
        if (exception.class.simpleName.matches('^(NotModified|NotFound)Exception$')) {
            println("Container " + createSleepingContainer.containerName + " has already been stopped")
        }
        else throw exception
    }

}

task removeDockerContainer(type: DockerRemoveContainer) {
    dependsOn stopDockerContainer
    targetContainerId { createDockerContainer.containerName }
    onError { exception ->
        if (exception.class.simpleName.matches('^(NotModified|NotFound)Exception$')) {
            println("Container " + createDockerContainer.containerName + " has already been removed")
        } else throw exception
    }

}

task removeSleepingContainer(type: DockerRemoveContainer) {
    dependsOn stopSleepingContainer
    targetContainerId { createSleepingContainer.containerName }
    onError { exception ->
        if (exception.class.simpleName.matches('^(NotModified|NotFound)Exception$')) {
            println("Container " + createSleepingContainer.containerName + " has already been removed")
        } else throw exception
    }

}

task stopDockerContainerOnStartup(type: DockerStopContainer) {
    targetContainerId { createDockerContainer.containerName }
    onError { exception ->
        if (exception.class.simpleName.matches('^(NotModified|NotFound)Exception$')) {
            println("Container " + createDockerContainer.containerName + " has already been stopped")
        } else throw exception
    }

}

task stopSleepingContainerOnStartup(type: DockerStopContainer) {
    targetContainerId { createSleepingContainer.containerName }
    onError { exception ->
        if (exception.class.simpleName.matches('^(NotModified|NotFound)Exception$')) {
            println("Container " + createSleepingContainer.containerName + " has already been stopped")
        } else throw exception
    }

}

task removeDockerContainerOnStartup(type: DockerRemoveContainer) {
    dependsOn stopDockerContainerOnStartup
    targetContainerId { createDockerContainer.containerName }
    onError { exception ->
        if (exception.class.simpleName.matches('^(NotModified|NotFound)Exception$')) {
            println("Container " + createDockerContainer.containerName + " has already been removed")
        } else throw exception
    }
}

task removeSleepingContainerOnStartup(type: DockerRemoveContainer) {
    dependsOn stopSleepingContainerOnStartup
    targetContainerId { createSleepingContainer.containerName }
    onError { exception ->
        if (exception.class.simpleName.matches('^(NotModified|NotFound)Exception$')) {
            println("Container " + createSleepingContainer.containerName + " has already been removed")
        } else throw exception
    }
}

task pushDockerImage(type: DockerPushImage) {
    dependsOn buildDockerImage
    imageName = dockerImageName
    tag = version
}