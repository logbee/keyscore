:descriptors_base: ../keyscore-model/src/main/proto/io/logbee/keyscore
:contrib_base: ../keyscore-pipeline/keyscore-pipeline-contrib/src/main/scala/io/logbee/keyscore/pipeline/contrib
:xrefstyle: short

= Building custom Blocks =

*How to read this chapter*:

- If you are a new block-developer -- nice to see you here, we are curious about your feedback -- you can simply read this
chapter from top to bottom starting with the <<Introduction>>.

- If you are already familiar with the concepts of blocks but need some details jump to the sections about
the block in question. <<block-types-brief-summary>> is a good starting point.

- If you are a block-developer veteran but you have forgotten some API details of the programming language you are using,
please refer to the corresponding documentation.

== Introduction ==

Pipelines are build by concatenating blocks. A block receives data from it's predecessor, mutates it and
passes the data to the next block. There are five types of blocks. The main difference between these types of blocks are
the number of in- and out-ports and therefore how they can be combined to build a pipeline:

[#example-pipeline]
.Example pipeline, illustrating the five different types of blocks.
[ditaa]
....
+----------+                                                                              +----------+
|          |                                                                              |          |
|  Source  +-----+                                                                 +----->|   Sink   |
|          |     |                                                                 |      |          |
+----------+     |                                                                 |      +----------+
                 |      +-----------+       +------------+       +-----------+     |
                 +----->|           |       |            |       |           +-----+
                        |   Merge   +------>|   Filter   +------>|   Branch  |
                 +----->|           |       |            |       |           +-----+
                 |      +-----------+       +------------+       +-----------+     |
+----------+     |                                                                 |      +----------+
|          |     |                                                                 |      |          |
|  Source  +-----+                                                                 +----->|   Sink   |
|          |                                                                              |          |
+----------+                                                                              +----------+
....

The following table provides a very brief summary of each type of block. See the sections below for more information
about each block.

[#block-types-brief-summary]
.Brief summary of each block type.
[cols=2*]
|===
|<<Source>>
|A Source-Block shapes the beginning of a pipeline as shown on the left-hand side in <<#example-pipeline>>.
 A source has a single out-port to feed data into a pipeline. Often a source is used to communicate with an external
 system to query data from that system and feed it into the pipeline.

|<<Sink>>
|A Sink-Block, illustrated on the right-hand side in <<#example-pipeline>> shapes the end of a pipeline. A sink
has a single in-port and consumes data from the pipeline. Often a sink is used to communicate with an external
system to pass the data at the end of a pipeline to that system.

|<<Filter>>
|A Filer-Block mutates, transforms enhances or reduces the data moving through it. As shown in <<#example-pipeline>>
it has a single in- and out-port.

|<<Branch>>
|A Branch-Block is a special kind of block as it is capable of splitting the flow of data into two branches as shown
in <<#example-pipeline>>. Therefore it has a single in- but two out-ports.

|<<Merge>>
|A Merge-Block is the counterpart of a Branch-Block. As illustrated in <<#example-pipeline>> a Merge-Block combines
two flows into one. Therefore it has two in- and one out-port.
|===

== Descriptor API ==
One of the key features is that all blocks are described by a meta-model. This meta-model is build by the so
called Descriptor API. The Descriptor API facilitates a block-developer to describe various aspects of a block. It is
important to understand the importance of the Descriptor API and the resulting meta-model. The meta-model allows as an example
the creation of an agnostic web-ui. Because of the meta-model, no changes have to be made to the web-ui when a new block
is added to the system. Instead the forms, buttons etc. presented to the users are rendered according to the meta-model.

=== Protobuf ===
To allow the development of blocks in different programing languages the Descriptor API is mostly build with
https://developers.google.com/protocol-buffers/[Protocol Buffers] hereinafter called Protobuf. Protobuf is a flexible,
efficient, automated mechanism for serializing and deserializing structured data. Protobuf uses an
 https://en.wikipedia.org/wiki/Interface_description_language[interface definition language (IDL)] and a source code
 generator to do this job.

To keep this documentation up-to-date and language agnostic, most parts of the Descriptor API are described with the help
of Protobuf code. For developers new to Protobuf this section is a brief introduction besides the official
https://developers.google.com/protocol-buffers/docs/proto3[documentation]. It is not important to understand all aspects
of the Protobuf IDL in depth. Rather, to understand the examples within this document.

Here is simple example to illustrate the most important bits:

[source]
----
message Request { <1>
    int32 result_per_page = 1; <2>
    Query query = 2 [(scalapb.field).no_box = true]; <3>
}

message Query {
    string query = 1;
    QueryType type = 2;
}

/* Which kind of query */ <4>
enum QueryType { <5>
    XPath = 0; <6>
    JSONPath = 1;
}
----

. Due to the background of Protobuf as foundation for serialization of messages a type definition starts with the
keyword `message`.

. Similar to structs in the C programming language. A message type consists of a series of fields. A field is defined by
a https://developers.google.com/protocol-buffers/docs/proto3#scalar[scalar type] or a complex type (eg. `int32`) a name
(eg. `result_per_page`) and a field number (eg. `= 1`).

. A complex type is just another message type defined in the same or another `.proto` file. It is also possible to add
attributes to control the code generation for example `[(scalapb.field).no_box = true]`.

. Comments use C/C++-style // and /* ... */ syntax.

. Besides normal message types, Protobuf offers https://developers.google.com/protocol-buffers/docs/proto3#enum[enumeration types]
known from other programming languages like https://en.wikipedia.org/wiki/Enumerated_type#Java[Java] which behave in a
similar manner.



== Blocks ==

=== Source ===

[source]
----
include::{descriptors_base}/descriptor.proto[tags=SourceDescriptor]
----

=== Sink ===

[source]
----
include::{descriptors_base}/descriptor.proto[tags=SinkDescriptor]
----

=== Filter ===

[source]
----
include::{descriptors_base}/descriptor.proto[tags=FilterDescriptor]
----

=== Branch ===

[source]
----
include::{descriptors_base}/descriptor.proto[tags=BranchDescriptor]
----

=== Merge ===

[source]
----
include::{descriptors_base}/descriptor.proto[tags=MergeDescriptor]
----

== Parameters ==

=== Boolean Parameter ===

==== When to use ====
- If a user should be able to turn a certain behaviour of a block *on* or *off*.

==== When NOT to use ====
- If their are more behaviours a user can choose not independently. Prefer: <<Choice Parameter>>

==== Specification ====
The `BooleanParameterDescriptor` offers a default value field to define which value (`true`/`false`) should be set initially.
It is also possible to choose whether the parameter is mandatory and the user has to configure it or not.

[source]
----
include::{descriptors_base}/descriptor.proto[tags=BooleanParameterDescriptor]
----

==== Examples ====
- Based on a boolean parameter the `Fingerprint` block encodes the computed hash sum to
https://en.wikipedia.org/wiki/Base64[Base64] or not.

=== Text Parameter ===

==== When to use ====
- If a user should be able enter simple text.

==== When NOT to use ====
- If the user should enter a password.
- If the user should enter just simple numbers. Prefer <<Number Parameter>> / <<Decimal Parameter>>
- If the user should enter multiple independent strings used to configure the same block behaviour. Prefer <<Text-List Parameter>>

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=TextParameterDescriptor]
----

=== Expression Parameter ===

==== When to use ====
- If a user should enter an expression (RegEx, Glob, Grok, JSONPath).

==== When NOT to use ====
- If the user should enter simple text. Prefer <<Text Parameter>>
- If the text entered by the user should be validated against a regular expression. Prefer: <<Text Parameter>>

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=ExpressionParameterDescriptor]
----

[source]
----
include::{descriptors_base}/descriptor.proto[tags=ExpressionType]
----

=== Number Parameter ===

==== When to use ====
- If a user should be able enter integers.
- If a user should enter port numbers.

==== When NOT to use ====
- If the user should enter decimals. Prefer <<Decimal Parameter>>
- If the user should enter numbers mixed with text. Prefer <<Text Parameter>>
- If a user should enter a PIN or secret number.

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=NumberParameterDescriptor]
----

=== Decimal Parameter ===

==== When to use ====
- If a user should be able enter decimals.

==== When NOT to use ====
- If the user should enter integers. Prefer <<Number Parameter>>
- If the user should enter decimals mixed with text. Prefer <<Text Parameter>>

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=DecimalParameterDescriptor]
----

=== Field-Name Parameter ===

==== When to use ====
- If a user should be able enter names of fields.

==== When NOT to use ====
- If the user should enter arbitrary text. Prefer <<Text Parameter>>

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=FieldNameParameterDescriptor]
----

=== Field-Name-Pattern Parameter ===

==== When to use ====

==== When NOT to use ====

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=FieldNamePatternParameterDescriptor]
----

=== Field Parameter ===

==== When to use ====
- If a user should be able enter the name and value of a field.

==== When NOT to use ====
- If the user should enter the name of a field only. Prefer <<Field-Name Parameter>>
- If the user should enter arbitrary text. Prefer <<Text Parameter>>

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=FieldParameterDescriptor]
----

=== Text-List Parameter ===

==== When to use ====
- If a user should be able enter a list of arbitrary text.
- If a user should be able to enter multiple independent strings.

==== When NOT to use ====
- If the user should enter a PIN or password (a secret).
- If the user should only enter a single line or word. Prefer <<Text Parameter>>

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=TextListParameterDescriptor]
----

=== Field-Name-List Parameter ===

==== When to use ====
- If a user should be able enter a list of field-names.

==== When NOT to use ====
- If a user should be able enter a list of arbitrary text. Prefer <<Text-List Parameter>>

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=FieldNameListParameterDescriptor]
----

=== Field-List Parameter ===

==== When to use ====
- If a user should be able enter the name and value of multiple fields.

==== When NOT to use ====
- If the user should enter the name of a single field only. Prefer <<Field-Name Parameter>>
- If the user should enter a list of arbitrary text. Prefer <<Text-List Parameter>>

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=FieldListParameterDescriptor]
----

=== Choice Parameter ===

==== When to use ====
- If a user should be able to choose one or more options of a predefined list.

==== When NOT to use ====

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=ChoiceParameterDescriptor]
----

===== Min / Max =====
- With `min` a block-developer can specified how many `Choices` a user has to select *at least*. Default: 0
- With `max` a block-developer can specify how many `Choices` a user can select *at most*. Default: 0

===== Choices =====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=Choice]
----

=== ParameterGroupDescriptor ===

==== When to use ====

==== When NOT to use ====

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=ParameterGroupDescriptor]
----

[source]
----
include::{descriptors_base}/descriptor.proto[tags=ParameterGroupCondition]
----

[source]
----
include::{descriptors_base}/descriptor.proto[tags=BooleanParameterCondition]
----

=== Field-Directive-Sequence Parameter ===

==== When to use ====

==== When NOT to use ====

==== Specification ====
[source]
----
include::{descriptors_base}/descriptor.proto[tags=FieldDirectiveSequenceParameterDescriptor]
----

[source]
----
include::{descriptors_base}/descriptor.proto[tags=DirectiveRef]
----

[source]
----
include::{descriptors_base}/descriptor.proto[tags=FieldDirectiveDescriptor]
----

== Localization ==
A very important part when offering a UI to a wide user-base is localisation. You have to support different languages so
every user can switch to her preferred language. Only a block-developer knows the names, descriptions and texts of a block
which get displayed within the UI. Therefore the block-developer has to provide the translations. The descriptor API
offers special structures to pass localisation information and translations.

The key point is the usage of `TextRefs`. Instead of using the text to display directly a `TextRef` refers to a `TranslationMapping`.
A `TranslationMapping` maps `Locales` to the proper text translated in the language denoted by the `Locale` it self.
At the end a `Localization` consists of a list of all `Locales` the `Localization` provides and all `TranslationMappings`.
<<#localization-classdiagram-overview>> illustrates the described concept. This allows, for example the manager-ui
to select the text to display based on the `TextRef` given by a parameter and the users Locale.

[#localization-classdiagram-overview]
.Class-diagram illustrating the assotiations between Localization, TextRef, Locale and TranslationMapping.
[ditaa]
....
+--------------+                 +--------------------+
|              |---------+       |                    |--------+       +--------+
| Localization | TextRef +------>| TranslationMapping | Locale +------>| String |
|              |---------+       |                    |--------+       +--------+
+-------+------+                 +--------------------+
        |
        |
        v0..n
   +----------+
   |  Locale  |
   |----------|
   | language |
   | country  |
   +----------+
....

== Icon ==

== Category ==
Categories help users to sort and find blocks quickly. A `Category` consists of a unique name and a localized display
name. Blocks can be assign to multiple categories.

[source]
----
include::{descriptors_base}/descriptor.proto[tags=Category]
----

The `Category` is a top level field of a <<Source>>, <<Sink>>, <<Filter>>, <<Branch>> and <<Merge>> block.

== Maturity ==
Often it is best to release software as soon as possible to get feedback from the user very early in development. The
drawback when software is released to early is a lack in quality or missing features.

A block-developer can assign a `Maturity` to his block to indicate a certain quality or age of the block.
The default value is `None` and `Maturity` ranges from `Official` to `Experimental`.

[source]
----
include::{descriptors_base}/descriptor.proto[tags=Maturity]
----

The `Maturity` is a top level field of a <<Source>>, <<Sink>>, <<Filter>>, <<Branch>> and <<Merge>> block.
