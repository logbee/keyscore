import com.bmuschko.gradle.docker.tasks.network.DockerCreateNetwork
import com.bmuschko.gradle.docker.tasks.network.DockerInspectNetwork
import org.apache.tools.ant.filters.EscapeUnicode

buildscript {
    repositories {
        mavenCentral()
        jcenter()
        maven {
            url 'https://plugins.gradle.org/m2/'
        }
    }

    dependencies {
        classpath 'com.bmuschko:gradle-docker-plugin:3.3.2'
        classpath 'gradle.plugin.com.google.protobuf:protobuf-gradle-plugin:0.8.5'
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.4'
        classpath 'com.github.jruby-gradle:jruby-gradle-plugin:1.6.0'
        classpath 'org.asciidoctor:asciidoctor-gradle-plugin:1.5.9.2'
        classpath "de.undercouch:gradle-download-task:4.0.0"
        classpath "gradle.plugin.de.inetsoftware:SetupBuilder:4.8.6"
    }
}

apply plugin: 'idea'
apply plugin: 'distribution'
apply plugin: 'com.bmuschko.docker-remote-api'

ext {
    dockerRegistryUser = getBuildPropertyValue("logbee.quay.user")
    dockerRegistryPassword = getBuildPropertyValue("logbee.quay.password")
    dockerRegistryUrl = 'https://quay.io/'
    bintrayUser = getBuildPropertyValue("bintray.user")
    bintrayKey = getBuildPropertyValue("bintray.key")
    bintrayUserOrg = 'logbee'
    publicationRepositoryUrl = getBuildPropertyValue("publication.repository.url")
    publicationRepositoryUser = getBuildPropertyValue("publication.repository.user")
    publicationRepositoryPassword = getBuildPropertyValue("publication.repository.password")
}

if (!isDockerRegistryUserConfigured()) logger.warn("No registry credentials for: $dockerRegistryUrl - logbee.quay.user is not set.")
if (!isDockerRegistryPasswordConfigured()) logger.warn("No registry credentials for: $dockerRegistryUrl - logbee.quay.password is not set.")
if (!isBintrayUserConfigured()) logger.warn("No bintray user - bintray.user is not set.")
if (!isBintrayKeyConfigured()) logger.warn("No bintray key - bintray.key is not set.")
if (!isPublicationRepositoryUrlConfigured()) logger.warn("Publication tasks may fail due to missing repository url - set 'publication.repository.url'")
if (!isPublicationRepositoryUserConfigured()) logger.warn("Publication tasks may fail due to missing repository user - set 'publication.repository.user'")
if (!isPublicationRepositoryPasswordConfigured()) logger.warn("Publication tasks may fail due to missing repository password - set 'publication.repository.password'")

subprojects {

    version = rootProject.version
    group = "io.logbee.${rootProject.name}"
    ext.url = 'https://github.com/logbee/keyscore/'
    ext.scmUrl = 'https://github.com/logbee/keyscore/'
    ext.scmConnection = 'git@github.com:logbee/keyscore.git'
    ext.scmDevConnection = 'git@github.com:logbee/keyscore.git'
    ext.buildDate = new Date().format('yyyy-MM-dd HH:mm:ss ZZZZ')
    ext.revision = { ->
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-parse', '--short', 'HEAD'
            standardOutput = stdout
        }
        return stdout.toString().trim()
    }()
    ext.revisionDate = { ->
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'show', '-s', '--format=%ci', 'HEAD'
            standardOutput = stdout
        }
        return stdout.toString().trim()
    }()

    repositories {
        mavenCentral()
        jcenter()
    }

    apply plugin: 'com.bmuschko.docker-remote-api'

    docker {

        if (isDockerRegistryUserConfigured() && isDockerRegistryPasswordConfigured()) {
            logger.info("Registry credentials set for: $dockerRegistryUrl")
            registryCredentials {
                url = dockerRegistryUrl
                username = "$dockerRegistryUser"
                password = "$dockerRegistryPassword"
            }
        }
    }

    plugins.withType(MavenPublishPlugin) {
        publishing {
            repositories {
                maven {
                    url publicationRepositoryUrl
                    credentials {
                        username publicationRepositoryUser
                        password publicationRepositoryPassword
                    }
                }
            }
        }
    }
}

configure ([
    project(':keyscore-agent'),
    project(':keyscore-agent:keyscore-agent-runtimes-api'),
    project(':keyscore-agent:keyscore-agent-runtimes-jvm'),
    project(':keyscore-frontier'),
    project(':keyscore-commons'),
    project(':keyscore-commons:keyscore-commons-logging'),
    project(':keyscore-commons:keyscore-commons-serialization'),
    project(':keyscore-commons:keyscore-commons-serviceregistry'),
    project(':keyscore-model'),
    project(':keyscore-pipeline:keyscore-pipeline-api'),
    project(':keyscore-pipeline:keyscore-pipeline-commons'),
    project(':keyscore-pipeline:keyscore-pipeline-contrib'),
    project(':keyscore-pipeline:keyscore-pipeline-testkit'),
    project(':keyscore-test-fixtures'),
]) {

    project.apply plugin: 'scala'
    project.apply plugin: 'maven'
    project.apply plugin: 'maven-publish'
    project.apply plugin: 'com.jfrog.bintray'
    project.apply plugin: 'distribution'

    repositories {
        mavenCentral()
    }

    bintray {
        user = "$bintrayUser"
        key = "$bintrayKey"
    }

    task generatePomXml {
        def filePath = "$buildDir/tmp/maven/pom.xml"
        group = 'Publishing'
        description = 'Generates a maven pom file.'
        outputs.file(filePath)
        doLast {
            pom{}.withXml {
                buildPomXml(project, asNode())
            }.writeTo(filePath)
        }
    }

    compileScala {
        scalaCompileOptions.additionalParameters = [
            "-deprecation",
            "-feature",
//            "-Ywarn-unused-import"
        ]
    }

    jar {
        exclude('**/.keep')
        manifest.attributes([
            'Implementation-Title'         : project.name,
            'Implementation-Version'       : version,
            'Implementation-Revision'      : revision,
            'Implementation-Revision-Date' : revisionDate,
            'Implementation-Build-Date'    : buildDate,
            'Implementation-Vendor'        : 'logbee.io'
        ])
        from (rootProject.projectDir) {
            include 'LICENSE'
        }
        into("META-INF/maven/$project.group/$project.name") {
            from generatePomXml
        }
    }

    test {
        testLogging {
            events 'started', 'passed', 'skipped', 'failed'
            exceptionFormat "full"
        }
    }

    task sourcesJar(type: Jar, dependsOn: classes) {
        classifier = 'sources'
        from sourceSets.main.allSource
    }

    task scaladocJar(type: Jar, dependsOn: scaladoc) {
        classifier = 'scaladoc'
        from scaladoc.destinationDir
    }

    // TODO: Enable scaladoc tasks when https://github.com/gradle/gradle/issues/9855 has been fixed.
    scaladoc.enabled = false
    scaladocJar.enabled = false

    artifacts {
        archives sourcesJar
        archives scaladocJar
    }

    //This overrides the copy behaviour for .properties-files (Resource Bundles), so that during Gradle builds (processResources),
    //the Unicode-characters get escaped, therefore can be decoded with ISO-8859-1, which JDK8 uses to read .properties-files.
    project.tasks.withType(ProcessResources).each { task ->
        task.from(task.getSource()) {
            include '**/*.properties'
            filter(EscapeUnicode)
        }
    }

    task escapeUnicodeInResourceBundles {
        def files = sourceSets.main.resources.asFileTree.matching {include '**/*.properties'}.files
        def cmd = ['native2ascii', '-encoding', 'utf8']
        doLast {
            files.forEach({ file ->
                exec {
                    workingDir file.parentFile
                    commandLine cmd.plus(file.name).plus(file.name)
                }
            })
        }
    }
}

configure ([
    project(':keyscore-manager')
]) {
    project.apply plugin: 'distribution'
}

configure ([
    project(':doc')
]) {
    project.apply plugin: 'com.github.jruby-gradle.base'
    project.apply plugin: 'org.asciidoctor.convert'
    project.apply plugin: 'distribution'

    repositories {
        maven { url "http://rubygems-proxy.torquebox.org/releases" }
    }

    dependencies {
        gems 'rubygems:asciidoctor-diagram:1.5.12'
    }

    asciidoctorj {
        version = '1.6.1'
    }

    asciidoctor {
        dependsOn jrubyPrepare
        requires = ['asciidoctor-diagram']
        sourceDir = projectDir
        sources {
            include '*.adoc'
        }
        resources {
            from("$projectDir/resources/images/") {
                include '**/*.png'
                include '**/*.svg'
                into "resources/images"
            }
            from("$projectDir/resources/") {
                include '**/*.css'
                into "resources"
            }
        }
        outputDir = buildDir
        gemPath = jrubyPrepare.outputDir
        options header_footer: true
        attributes([
            'build-gradle': file('build.gradle'),
            'source-highlighter' : 'coderay',
//            'imagesdir': './resources/images',
//            'imagesoutdir': "$buildDir/resources/images",
//            'imagesoutdir': "./resources/images",
            'toc-title': 'Table of Contents',
            'toc': 'left',
            'toclevels': 3,
            'icons': 'font',
            'setanchors': '',
            'idprefix': '',
            'idseparator': '-',
            'docinfo1': '',
            'source-highlighter': 'coderay',
            'stylesheet': 'resources/keyscore.css',
            'linkcss': true,
        ])
    }

    distributions {
        main {
            baseName = "keyscore-${project.name}"
            contents {
                from(asciidoctor) {
                    include 'html5/**'
                    exclude 'html5/.asciidoctor'
                }
            }
        }
    }
}

distributions {
    main {
        contents {
            from(project(':doc').tasks['installDist']) {
                into 'doc'
            }
            from(project(':keyscore-agent').tasks['installDist']) {
                into 'keyscore-agent'
            }
            from(project(':keyscore-frontier').tasks['installDist']) {
                into 'keyscore-frontier'
            }
            from(project(':keyscore-manager').tasks['installDist']) {
                into 'keyscore-manager'
            }
        }
    }
}

task setupDockerNetwork(type: DockerInspectNetwork) {
    finalizedBy 'createContainerNetwork'
    networkId = project.properties['containerNetwork']
    setupDockerNetwork.ext.createNetwork = false
    onError { exception ->
        if (exception.message.contains('not found')) {
            println("Network " + project.properties['containerNetwork'] + " not found")
            setupDockerNetwork.ext.createNetwork = true
        } else throw exception
    }
}

task createContainerNetwork(type: DockerCreateNetwork) {
    onlyIf {
        setupDockerNetwork.createNetwork
    }
    networkId = project.properties['containerNetwork']
}

private def isDockerRegistryUserConfigured() {
    return ext.dockerRegistryUser != null && !ext.dockerRegistryUser.empty
}

private def isDockerRegistryPasswordConfigured() {
    return ext.dockerRegistryPassword != null && !ext.dockerRegistryPassword.empty
}

private def isBintrayUserConfigured() {
    return ext.bintrayUser != null && !ext.bintrayUser.empty
}

private def isBintrayKeyConfigured() {
    return ext.bintrayKey != null && !ext.bintrayKey.empty
}

private def isPublicationRepositoryUrlConfigured() {
    return ext.publicationRepositoryUrl != null && !ext.publicationRepositoryUrl.empty
}

private def isPublicationRepositoryUserConfigured() {
    return ext.publicationRepositoryUser != null && !ext.publicationRepositoryUser.empty
}

private def isPublicationRepositoryPasswordConfigured() {
    return ext.publicationRepositoryPassword != null && !ext.publicationRepositoryPassword.empty
}

def static buildPomXml(project, root) {

    def listOfDevelopers = [
        ["kkdh", "Elmar Schug", "elmar.schug@jayware.org", "Europe/Berlin"],
        ["EndallBatan93", "Manuel Hinke", "manuel.hinke@daimler.com", "Europe/Berlin"],
        ["mlandth", "Max Landthaler", "max.landthaler@posteo.de", "Europe/Berlin"],
        ["Avoliq", "Maximilian Karthan", "ich@max-karthan.de", "Europe/Berlin"]
    ]

    root.appendNode('name', "${project.group}:${project.name}")
    root.appendNode('description', "${project.description}")
    root.appendNode('url', "${project.url}")
    root.appendNode('inceptionYear', '2017')

    def scm = root.appendNode('scm')
    scm.appendNode('url', "${project.scmUrl}")
    scm.appendNode('connection', "${project.scmConnection}")
    scm.appendNode('developerConnection', "${project.scmDevConnection}")

    def developers = root.appendNode('developers')
    listOfDevelopers.each { element ->
        def dev = developers.appendNode('developer')
        dev.appendNode('id', element[0])
        dev.appendNode('name', element[1])
        dev.appendNode('email', element[2])
        dev.appendNode('timezone', element[3])
    }

    def license = root.appendNode('licenses').appendNode('license')
    license.appendNode('name', 'Apache License 2.0')
    license.appendNode('url', 'http://www.apache.org/licenses/LICENSE-2.0')
    license.appendNode('distribution', 'repo')
}

static def getBuildPropertyValue(String name) {
    def env = System.getenv()
    def envName = name.toUpperCase().replace('.', '_')

    if (env.containsKey(envName)) {
        return env.get(envName)
    }
    else {
        return System.getProperty(name)
    }
}
